# Effects

A pure function accepts arguments and produces a result.
Nothing more.
Because of this we can combine pure functions and the result will also be a pure function.
Pure functions are basically mathematical functions, and so obey the laws of math.
This means we can reason about pure functions in a mathematical manner.

For example, identical arguments produce the same result every time.
It's as if a pure function is only a lookup table.

Because of all the benefits of pure functions, we clearly want to use them everywhere we can.
A program composed of pure functions would be very reliable indeed.
It would also have no interactions with the outside world, neither reading from nor writing to.
A program comprised solely of pure functions has no *effect* upon the world.
Without that, the only evidence that you ran the program is the additional warmth generated by your computer.

A program that does interact with the world introduces a lot of uncertainty.
In particular, the world is a completely uncertain state, as far as the program is concerned.
The output effects of the program depend on the input effects when the program runs.
No longer are identical inputs producing the same result, every time. {{???}}

With the addition of all this uncertainty, errors become a serious possibility.
Errors also have an affect on the world (if they do not there is no point to their existence).

The problem is this: functions that affect or are affected by the world do so by directly contacting the world.
In the previous chapter we solved the problem of needing to return extra information by boxing all necessary information into the function's result value, as a monad.
In this chapter we solve the problem of effects by boxing further information into the result monad.
Doing so captures the effects so we can keep an eye on them.
We write as many pure functions as possible, and when we need to do something effect-full, we isolate that in its own function, and limit the spread of uncertainty.
The result is not deterministic, but we have isolated the effects.
This allows us to much more effectively reason about the behavior of our program.

## Basics

Consider a function that affects its surroundings:

```scala
trait X
object X:
  var x: Int = 0

def combine(a: Int, b: Int): Int =
  X.x += 1
  a + b + X.x

combine(1, 2)
// res0: Int = 4
combine(1, 2)
// res1: Int = 5
```

Because `combine` both writes to and reads from the global variable `X.x`, identical arguments will *not* produce the same result every time.
`combine` modifies `X.x` and also depends on it to produce its result.
`combine` is not pure.

We want to manage this effect `X`.
We repeat the trick we used in [Monads] but instead of packaging the return value with failure information, we package it with the type `X`:

```scala
trait XIO[IO, R]

case class IntXIO(i: Int) extends XIO[X, Int]

def combine2(a: Int, b: Int): XIO[X, Int] =
  X.x += 1
  IntXIO(a + b + X.x)

combine2(1, 2)
// res2: XIO[X, Int] = IntXIO(6)
```

At first glance this doesn't seem to fix anything.
`combine2` returns an `XIO` instead of the simple `Int` produced by `combine`.
The call to `combine2` shows that we still see the side effect.
What have we achieved?

We haven't prevented the side effect produced by the accesses to `X.x`, but that is presumably an essential part of the function.
What we have done is *tracked* that effect by tagging it inside the `XIO` result.
The fact that a side effect occurs is now tagged inside the type of `XIO`, and this information persists at runtime.

What can we do with this information?

We need to interpret this effect information at runtime.
To achieve this we delay the evaluation of the program and hand it to an *interpreter*, which knows what to do with the effects.

{{ This seems challenging (albeit illuminating).
If the example were extremely specific (say, an interpreter that *only* knows about `IntXIO`) perhaps it could work.}}


## Automatically attached experiments.
 These are included at the end of this 
 chapter because their package in the
 experiments directory matched the name
 of this chapter. Enjoy working on the
 code with full editor capabilities :D
 
 

### experiments/src/main/scala/effects/CustomRandomZIO.scala
```scala
package effects

import zio.{
  BuildFrom,
  Chunk,
  Console,
  Random,
  UIO,
  ZIO,
  ZLayer
}
import zio.Console.printLine

trait RandomIntBounded:
  def nextIntBounded(n: Int): UIO[Int]

object RandomIntBounded:
  object RandomIntBoundedLive
      extends RandomIntBounded:
    override def nextIntBounded(
        n: Int
    ): UIO[Int] =
      ZIO.succeed(scala.util.Random.nextInt(n))

class FakeRandomIntBounded(hardcodedValue: Int)
    extends RandomIntBounded:
  override def nextIntBounded(n: Int): UIO[Int] =
    UIO.succeed(hardcodedValue)

def luckyZ(
    i: Int
): ZIO[RandomIntBounded, Nothing, Boolean] =
  ZIO
    .environmentWithZIO[RandomIntBounded](
      _.get.nextIntBounded(i)
    )
    .map(_ == 0)

object LuckyZ extends zio.ZIOAppDefault:
  def run =
    val myRandom: ZLayer[
      Any,
      Nothing,
      RandomIntBounded
    ] = ZLayer.succeed(FakeRandomIntBounded(0))

    myAppLogic
      .provideLayer(myRandom)
      // does not work for some reason
      // .injectSome[Console](myRandom)
      .exitCode

  val myAppLogic =
    for
      isLucky <- luckyZ(50)
    yield
      if isLucky then
        "You are lucky!"
      else
        "Sorry"
end LuckyZ

trait RandomIntBetween:
  def intBetween(low: Int, high: Int): UIO[Int]

object RandomIntBetween:
  object RandomIntBetween
      extends RandomIntBetween:
    override def intBetween(
        low: Int,
        high: Int
    ): UIO[Int] =
      ZIO.succeed(
        scala.util.Random.between(low, high)
      )

class FakeRandomIntBetween(hardcodedValue: Int)
    extends RandomIntBetween:
  override def intBetween(
      low: Int,
      high: Int
  ): UIO[Int] = UIO.succeed(hardcodedValue)

def effectfulIntBetween(low: Int, high: Int) =
  ZIO.environmentWithZIO[RandomIntBetween](
    _.get.intBetween(high, low)
  )

@main
def demoStuff(): Unit =

  def foo(arg: => Int): Int =
    val x = arg
    println("In foo")
    x

  foo {
    println("hi first")
    10
  }

  def foo2(arg: () => Int): Int =
    arg()
    println("In foo2")
    arg()

  foo2 { () =>
    println("hi")
    10
  }
end demoStuff

```


### experiments/src/main/scala/effects/IOVars.scala
```scala
package effects

object IOVars {
// If the code is taking input from a non-local
  // source, or using input/output, it is
  // considered
  // an effect.

}

```


### experiments/src/main/scala/effects/mutableVars.scala
```scala
package effects

object mutableVars:
  // Mutable variables can be considered as
  // effects. They can change the behavior of a
  // function while not being an input.

  var x = 5

  def addXnY(y: Int) = x + y

  @main
  def mutableVarsEx =
    println(addXnY(3)) // This gives 8
    x = 2
    println(addXnY(3)) // This gives 5

// The calls to addXnY have the same inputs, yet
// give different outputs. This does
// not follow the rules of a pure function.

```


### experiments/src/main/scala/effects/randomComponents.scala
```scala
package effects

import scala.util.Random

object randomComponents:

  // Anything that has a randomly generated
  // component is an effect

  def randNum: Unit =
    val rand = Random.nextInt(100)
    println(rand)

  @main
  def randNumEx =
    randNum
    randNum
// These have the same input, yet different
// outputs.

```


### experiments/src/main/scala/effects/temporalVars.scala
```scala
package effects

import java.util.Calendar

object temporalVars:

  // Time based functions are effectful because
  // they
  // rely on a variable that is constantly
  // changing.

  def sayTime() =
    val curTime = Calendar.getInstance()
    val curOption: Option[java.util.Calendar] =
      curTime match
        case null =>
          None
        case x: java.util.Calendar =>
          Some(x)
    val curMin =
      curOption match
        case None =>
          println("oof")
        case Some(s) =>
          s.get(Calendar.SECOND)
    println(curMin)

  @main
  def temporalVarsEx =
    sayTime()
    Thread.sleep(3000)
    sayTime()

end temporalVars

// The input for the variable is the same, yet
// there is a different output.
// The clock is thus considered an effect.

```

            